<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 5.4.4 (402282)"/><meta name="author" content="jennyzj"/><meta name="created" content="2014-05-26 07:51:24 +0000"/><meta name="updated" content="2014-05-26 07:53:37 +0000"/><title>基于前后端分离的多终端适配</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<h2 style="box-sizing: border-box; font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-weight: 500; line-height: 1.1; color: rgb(51, 51, 51); font-size: 30px; border-bottom-width: 1px; border-bottom-style: dashed; border-bottom-color: rgb(221, 221, 221); background-color: rgb(255, 255, 255);">前言</h2>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">近年来各站点基于 Web 的多终端适配进行得如火如荼，行业间也发展出依赖各种技术的解决方案。有如基于浏览器原生 CSS3 Media Query 的响应式设计、基于云端智能重排的「云适配」方案等。本文则主要探讨在前后端分离基础下的多终端适配方案。</p>
<blockquote style="box-sizing: border-box; padding: 10px 20px; font-size: 17.5px; border-left-width: 5px; border-left-style: solid; border-left-color: rgb(238, 238, 238); color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; background-color: rgb(255, 255, 255);">
<h3 style="box-sizing: border-box; font-family: inherit; font-weight: 500; line-height: 1.1; color: inherit; font-size: 24px; border-bottom-width: 1px; border-bottom-style: dashed; border-bottom-color: rgb(221, 221, 221);">关于前后端分离</h3>
<p style="box-sizing: border-box;">关于前后端分离的方案，在<a href="http://ued.taobao.org/blog/2014/04/full-stack-development-with-nodejs/" style="box-sizing: border-box; background-color: transparent; color: rgb(66, 139, 202); text-decoration: none; background-position: initial initial; background-repeat: initial initial;">《前后端分离的思考与实践（一）》</a>中有非常清晰的解释。我们在服务端接口和浏览器之间引入 NodeJS 作为渲染层，因为 NodeJS 层彻底与数据抽离，同时无需关心大量的业务逻辑，所以十分适合在这一层进行多终端的适配工作。</p>
</blockquote>
<h2 style="box-sizing: border-box; font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-weight: 500; line-height: 1.1; color: rgb(51, 51, 51); font-size: 30px; border-bottom-width: 1px; border-bottom-style: dashed; border-bottom-color: rgb(221, 221, 221); background-color: rgb(255, 255, 255);">UA 探测</h2>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">进行多终端适配首先要解决的是 UA 探测问题，对于一个过来的请求，我们需要知道这个设备的类型才能针对对它输出对应的内容。现在市面上已经有非常成熟的兼容大量设备的 User Agent 特征库和探测工具，<a href="https://wiki.mozilla.org/Compatibility/UADetectionLibraries" style="box-sizing: border-box; background-color: transparent; color: rgb(66, 139, 202); text-decoration: none; background-position: initial initial; background-repeat: initial initial;">这里有 Mozilla 整理的一个列表</a>。其中，既有运行在浏览器端的，也有运行在服务端代码层的，甚至有些工具提供了 Nginx/Apache 的模块，负责解析每个请求的 UA 信息。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">实际上我们推荐最后一种方式。基于前后端分离的方案决定了 UA 探测只能运行在服务器端，但如果把探测的代码和特征库耦合在业务代码里并不是一个足够友好的方案。我们把这个行为再往前挪，挂在 Nginx/Apache 上，它们负责解析每个请求的 UA 信息，再通过如 HTTP Header 的方式传递给业务代码。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">这样做有几点好处：</p>
<ol style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">
<li style="box-sizing: border-box;">我们的代码里面无需再去关注 UA 如何解析，直接从上层取出解析后的信息即可。</li>
<li style="box-sizing: border-box;">如果在同一台服务器上有多个应用，则能够共同使用同一个 Nginx 解析后的 UA 信息，节省了不同应用间的解析损耗。</li>
</ol>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);"><a href="http://gtms03.alicdn.com/tps/i3/T1s8L7FFNcXXbvv3MO-968-509.png" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(66, 139, 202); text-decoration: none; background-position: initial initial; background-repeat: initial initial;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/dfa97c87a815ffb709149b46c0e9053f.png" height="509" width="968"/></a></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255); text-align: center; font-style: italic;">来自天猫分享的基于 Nginx 的 UA 探测方案</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">淘宝的 Tengine Web 服务器也提供了类似的模块 <a href="http://tengine.taobao.org/document/http_user_agent.html" style="box-sizing: border-box; background-color: transparent; color: rgb(66, 139, 202); text-decoration: none; background-position: initial initial; background-repeat: initial initial;">ngx_http_user_agent_module</a>。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">值得一提的是，选用 UA 探测工具时必须要考虑特征库的可维护性，因为市面上新增的设备类型越来越多，每个设备都会有独立的 User Agent，所以该特征库必须提供良好的更新和维护策略，以适应不断变化的设备。</p>
<h2 style="box-sizing: border-box; font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-weight: 500; line-height: 1.1; color: rgb(51, 51, 51); font-size: 30px; border-bottom-width: 1px; border-bottom-style: dashed; border-bottom-color: rgb(221, 221, 221); background-color: rgb(255, 255, 255);">建立在 MVC 模式中的适配方案</h2>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">取得 UA 信息后，我们就要考虑如果根据指定的 UA 进行终端适配了。即使在 NodeJS 层，虽然没有了大部分的业务逻辑，但我们依然把内部区分为 Model / Controller / View 三个模型。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);"><a href="http://gtms04.alicdn.com/tps/i4/T1oGP_FIlbXXc1sab4-200-220.png" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(66, 139, 202); text-decoration: none; background-position: initial initial; background-repeat: initial initial;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/695e760cb735fe6c7c7906ff452dff07.png" height="220" width="200"/></a></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">我们先利用上面的图，去解析一些已有的多终端适配方案。</p>
<h3 style="box-sizing: border-box; font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-weight: 500; line-height: 1.1; color: rgb(51, 51, 51); font-size: 24px; border-bottom-width: 1px; border-bottom-style: dashed; border-bottom-color: rgb(221, 221, 221); background-color: rgb(255, 255, 255);">建立在 Controller 上的适配方案</h3>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);"><a href="http://gtms03.alicdn.com/tps/i3/T1YkZcFMhXXXa36h6P-507-400.png" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(66, 139, 202); text-decoration: none; background-position: initial initial; background-repeat: initial initial;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/0937dcdbb94ad28a81cfb63d151c1d04.png" height="400" width="507"/></a></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">这种方案应该是最简单粗暴的处理方法。通过路由（Router）将相同的 URL 统一传递到同一个控制层（Controller）。控制层再通过 UA 信息将数据和模型（Model）逻辑派发到对应的展现（View）进行渲染，渲染层则按预先的约定提供了适配几个终端的模板。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">这种方案的好处是，保持了数据和控制层的统一性，业务逻辑只需处理一次遍可以应用在所有终端上。但这种场景只适合如展示型页面等低交互型的应用，一旦业务比较复杂，各个终端的 Controller 可能有各自的处理逻辑，这样如果还是共用一个 Controller ，会导致 Controller 非常的臃肿，无疑是一个错误的选择。</p>
<h3 style="box-sizing: border-box; font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-weight: 500; line-height: 1.1; color: rgb(51, 51, 51); font-size: 24px; border-bottom-width: 1px; border-bottom-style: dashed; border-bottom-color: rgb(221, 221, 221); background-color: rgb(255, 255, 255);">建立在 Router 上的适配方案</h3>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">为了解决上面遇到的问题，我们可以在 Router 上就将设备区分，针对不同的终端分发到不同的 Controller 上：</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);"><a href="http://gtms03.alicdn.com/tps/i3/T1UQr7FK8cXXXKYi.n-531-348.png" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(66, 139, 202); text-decoration: none; background-position: initial initial; background-repeat: initial initial;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/251663b7e599f596b9e0920f328521f7.png" height="348" width="531"/></a></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">这也是最常见的方案之一，大多表现在针对不同终端使用各自独立的一套应用。如 PC 淘宝首页和 WAP 版的淘宝首页，不同设备访问 <a href="http://www.taobao.com/" style="box-sizing: border-box; background-color: transparent; color: rgb(66, 139, 202); text-decoration: none; background-position: initial initial; background-repeat: initial initial;">www.taobao.com</a> ，服务器会通过 Router 的控制，重定向到 WAP 版的淘宝首页或者 PC 版的淘宝首页，它们各自是完全独立的两套应用。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">但这种方案无疑带来了数据和部分逻辑无法共用的问题，各种终端之间无法分享同一份数据和业务逻辑，产生大量重复性工作，效率低下。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">为了缓解这个问题，有人提出了优化后的方案：依然是在同一套应用里面，各个数据来源抽象成各个 Model，提供给不同终端的 Controller 组合使用：</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);"><a href="http://gtms01.alicdn.com/tps/i1/T1pR_fFGxaXXXGaK2H-685-520.png" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(66, 139, 202); text-decoration: none; background-position: initial initial; background-repeat: initial initial;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/46d36bdaee4b242ed2f07cae2af00e37.png" height="520" width="685"/></a></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">这个方案解决了前面数据无法共用的问题。在 Controller 上各个终端还是相互独立，但能共同使用同一批数据源，至少在数据上无需再针对终端类型开发独立的接口了。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">以上两种基于 Router 的方案，由于 Controller 的独立，各个终端可以为自己的页面实现不同的交互逻辑，保证了各终端自身足够的灵活度，这也是为什么大部分应用采用这种方案的主要原因。</p>
<h3 style="box-sizing: border-box; font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-weight: 500; line-height: 1.1; color: rgb(51, 51, 51); font-size: 24px; border-bottom-width: 1px; border-bottom-style: dashed; border-bottom-color: rgb(221, 221, 221); background-color: rgb(255, 255, 255);">建立在 View 层的适配方案</h3>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">这是淘宝下单页面使用的方案，不过区别是下单页将整体的渲染层放在了浏览器端，而不是 NodeJS 层。不过无论是浏览器还是 NodeJS，整体设计思路还是一致的：</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);"><a href="http://gtms02.alicdn.com/tps/i2/T18IvnFMtXXXc.mb7O-1327-494.png" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(66, 139, 202); text-decoration: none; background-position: initial initial; background-repeat: initial initial;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/d70a944a7ab6b06a3924606359be5850.png" height="494" width="1327"/></a></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">在这个方案里面，Router、Controller 和 Model 都无需关注设备信息，终端类型的判断完全交给展现层来处理。图中主要的模块是「View Factory」，Model 和 Controller 将数据和渲染逻辑传递过来之后，通过 View Factory 根据设备信息和其它状态（不仅仅是 UA 信息、也可以是网络环境、用户地区等等）从一堆预设好的组件（View Component）中抓取特定的组件，再组合成最终的页面。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">这种方案有几个优势：</p>
<ol style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">
<li style="box-sizing: border-box;">上层无需关注设备信息（UA），多终端的视频还是交由和最终展现最大关系的 View 层来处理；</li>
<li style="box-sizing: border-box;">不仅仅是多终端适配，除了 UA 信息，各个 View Component 还可以根据用户状态决定自身输出何种模版，如低网速下默认隐藏图片、指定地区输出活动 Banner。</li>
<li style="box-sizing: border-box;">每个 View Component 的不同模版间可以自行决定是否使用同一份数据、业务逻辑，提供十分灵活的实现方式。</li>
</ol>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">但明显的是，这个方案也是最复杂的，尤其是要考虑一些富交互的应用场景时，Router 和 Controller 也许无法保持这么纯粹。特别对于一些整体性比较强的业务，本身无法被拆分成组件，这种方案也许并不适用；而且对于一些简单的业务，使用这种架构可能不是最佳的选择。</p>
<h2 style="box-sizing: border-box; font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-weight: 500; line-height: 1.1; color: rgb(51, 51, 51); font-size: 30px; border-bottom-width: 1px; border-bottom-style: dashed; border-bottom-color: rgb(221, 221, 221); background-color: rgb(255, 255, 255);">最后</h2>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">以上是对几个多终端适配方案的总结，也许还有其它的方案，但总能对应到 MVC 框架中的某个或某些部分，结果都会大同小异。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">对于哪个方案最为通用且高效，我们暂时还没有结论，所以我们还是打算从业务实践中获得更多的灵感和需求，从而整理出一个通用框架作为「中途岛」前后端整体解决方案中的多终端适配规范。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);">也许你有更多的想法和建议，不妨在下面的评论中一起参与讨论。</p>
<span style="background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; letter-spacing: 0.03rem; line-height: 27.200000762939453px;">[链接们]</span>
<div><span style="background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; letter-spacing: 0.03rem; line-height: 27.200000762939453px;"><br/></span></div>
<h1 style="padding: 0px; font-size: 17px; line-height: 23px; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; background-color: rgb(255, 255, 255);">前后端分离的思考与实践（一）</h1>
<h2 style="padding: 0px; font-size: 24px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; line-height: 36px; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">也谈基于NodeJS的全栈式开发（基于NodeJS的前后端分离）</h2>
<hr style="padding: 0px; border: 0px; background-color: rgb(248, 248, 248); color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px;"/>
<div style="color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; border: 1px solid rgb(238, 238, 238); background-color: rgb(239, 239, 239); padding: 10px;">
<h3 style="padding: 0px; font-size: 18px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei';">前言</h3>
<p style=" padding: 0px;">为了解决传统Web开发模式带来的各种问题，我们进行了许多尝试，但由于前/后端的物理鸿沟，尝试的方案都大同小异。痛定思痛，今天我们重新思考了“前后端”的定义，引入前端同学都熟悉的NodeJS，试图探索一条全新的前后端分离模式。</p>
</div>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">随着不同终端(Pad/Mobile/PC)的兴起，对开发人员的要求越来越高，纯浏览器端的响应式已经不能满足用户体验的高要求，我们往往需要针对不同的终端开发定制的版本。为了提升开发效率，前后端分离的需求越来越被重视，后端负责业务/数据接口，前端负责展现/交互逻辑，同一份数据接口，我们可以定制开发多个版本。</p>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">这个话题最近被讨论得比较多，阿里有些BU也在进行一些尝试。讨论了很久之后，我们团队决定探索一套基于NodeJS的前后端分离方案，过程中有一些不断变化的认识以及思考，记录在这里，也希望看到的同学参与讨论，帮我们完善。</p>
<h2 style="padding: 0px; font-size: 24px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; line-height: 36px; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">一、什么是前后端分离？</h2>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">最开始组内讨论的过程中我发现，每个人对前后端分离的理解不一样，为了保证能在同一个频道讨论，先就什么是”前后端分离”达成一致。</p>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">大家一致认同的前后端分离的例子就是SPA(Single-page application)，所有用到的展现数据都是后端通过异步接口(AJAX/JSONP)的方式提供的，前端只管展现。<br/>
从某种意义上来说，SPA确实做到了前后端分离，但这种方式存在两个问题：</p>
<ul style="padding: 0px; list-style-position: initial; list-style-image: initial; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">
<li style=" padding: 0px;">WEB服务中，SPA类占的比例很少。很多场景下还有同步/同步+异步混合的模式，SPA不能作为一种通用的解决方案。</li>
<li style=" padding: 0px;">现阶段的SPA开发模式，接口通常是按照展现逻辑来提供的，有时候为了提高效率，后端会帮我们处理一些展现逻辑，这就意味着后端还是涉足了View层的工作，不是真正的前后端分离。</li>
</ul>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">SPA式的前后端分离，是从物理层做区分（认为只要是客户端的就是前端，服务器端的就是后端），这种分法已经无法满足我们前后端分离的需求，我们认为从职责上划分才能满足目前我们的使用场景：</p>
<ul style="padding: 0px; list-style-position: initial; list-style-image: initial; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">
<li style=" padding: 0px;">前端：负责View和Controller层。</li>
<li style=" padding: 0px;">后端：只负责Model层，业务处理/数据等。</li>
</ul>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">为什么去做这种职责的划分，后面会继续探讨。</p>
<h2 style="padding: 0px; font-size: 24px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; line-height: 36px; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">二、为什么要前后端分离？</h2>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">关于这个问题，玉伯的文章<a href="https://github.com/lifesinger/lifesinger.github.com/issues/184" style="text-decoration: none; color: rgb(12, 144, 220); transition: color 0.2s; -webkit-transition: color 0.2s;">Web研发模式演变</a>中解释得非常全面，我们再大概理一下：</p>
<h4 style="padding: 0px; font-size: 16px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">2.1 现有开发模式的适用场景</h4>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">玉伯提到的几种开发模式，各有各的适用场景，没有哪一种完全取代另外一种。</p>
<ul style="padding: 0px; list-style-position: initial; list-style-image: initial; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">
<li style=" padding: 0px;">比如后端为主的MVC，做一些同步展现的业务效率很高，但是遇到同步异步结合的页面，与后端开发沟通起来就会比较麻烦。</li>
<li style=" padding: 0px;">Ajax为主SPA型开发模式，比较适合开发APP类型的场景，但是只适合做APP，因为SEO等问题不好解决，对于很多类型的系统，这种开发方式也过重。</li>
</ul>
<h4 style="padding: 0px; font-size: 16px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">2.2 前后端职责不清</h4>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">在业务逻辑复杂的系统里，我们最怕维护前后端混杂在一起的代码，因为没有约束，M-V-C每一层都可能出现别的层的代码，日积月累，完全没有维护性可言。<br/>
虽然前后端分离没办法完全解决这种问题，但是可以大大缓解。因为从物理层次上保证了你不可能这么做。</p>
<h4 style="padding: 0px; font-size: 16px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">2.3 开发效率问题</h4>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">淘宝的Web基本上都是基于MVC框架webx，架构决定了前端只能依赖后端。<br/>
所以我们的开发模式依然是，前端写好静态demo，后端翻译成VM模版，这种模式的问题就不说了，被吐槽了很久。<br/>
直接基于后端环境开发也很痛苦，配置安装使用都很麻烦。为了解决这个问题，我们发明了各种工具，比如<a href="https://www.npmjs.org/package/vmarket" target="_blank" style="text-decoration: none; color: rgb(12, 144, 220); transition: color 0.2s; -webkit-transition: color 0.2s;">VMarket</a>，但是前端还是要写VM，而且依赖后端数据，效率依然不高。<br/>
另外，后端也没法摆脱对展现的强关注，从而专心于业务逻辑层的开发。</p>
<h4 style="padding: 0px; font-size: 16px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">2.4 对前端发挥的局限</h4>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作才能碰撞出火花，但由于后端框架限制，我们很难使用Comet、Bigpipe等技术方案来优化性能。</p>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">为了解决以上提到的一些问题，我们进行了很多尝试，开发了各种工具，但始终没有太多起色，主要是因为我们只能在后端给我们划分的那一小块空间去发挥。只有真正做到前后端分离，我们才能彻底解决以上问题。</p>
<h2 style="padding: 0px; font-size: 24px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; line-height: 36px; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">三、怎么做前后端分离？</h2>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">怎么做前后端分离，其实第一节中已经有了答案：</p>
<ul style="padding: 0px; list-style-position: initial; list-style-image: initial; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">
<li style=" padding: 0px;">前端：负责View和Controller层。</li>
<li style=" padding: 0px;">后端：负责Model层，业务处理/数据等。</li>
</ul>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/729cbb8123b8ae063a4c60aaaa1c7d95.png" height="263" width="555"/></p>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">试想一下，如果前端掌握了Controller，我们可以做url design，我们可以根据场景决定在服务端同步渲染，还是根据view层数据输出json数据，我们还可以根据表现层需求很容易的做Bigpipe,Comet,Socket等等，完全是需求决定使用方式。</p>
<h4 style="padding: 0px; font-size: 16px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">3.1 基于NodeJS“全栈”式开发</h4>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">如果想实现上图的分层，就必然需要一种web服务帮我们实现以前后端做的事情，于是就有了标题提到的“基于NodeJS的全栈式开发”</p>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/3048241f0faa6b7c78d4a8fe080af259.png" height="611" width="590"/></p>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">这张图看起来简单而且很好理解，但没尝试过，会有很多疑问。</p>
<ul style="padding: 0px; list-style-position: initial; list-style-image: initial; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">
<li style=" padding: 0px;">SPA模式中，后端已供了所需的数据接口，view前端已经可以控制，为什么要多加NodeJS这一层？</li>
<li style=" padding: 0px;">多加一层，性能怎么样？</li>
<li style=" padding: 0px;">多加一层，前端的工作量是不是增加了？</li>
<li style=" padding: 0px;">多加一层就多一层风险，怎么破？</li>
<li style=" padding: 0px;">NodeJS什么都能做，为什么还要JAVA？</li>
</ul>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">这些问题要说清楚不容易，下面说下我的认识过程。</p>
<h4 style="padding: 0px; font-size: 16px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">3.2 为什么要增加一层NodeJS？</h4>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">现阶段我们主要以后端MVC的模式进行开发，这种模式严重阻碍了前端开发效率，也让后端不能专注于业务开发。<br/>
解决方案是让前端能控制Controller层，但是如果在现有技术体系下很难做到，因为不可能让所有前端都学java，安装后端的开发环境，写VM。<br/>
NodeJS就能很好的解决这个问题，我们无需学习一门新的语言，就能做到以前开发帮我们做的事情，一切都显得那么自然。</p>
<h4 style="padding: 0px; font-size: 16px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">3.3 性能问题</h4>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">分层就涉及每层之间的通讯，肯定会有一定的性能损耗。但是合理的分层能让职责清晰、也方便协作，会大大提高开发效率。分层带来的损失，一定能在其他方面的收益弥补回来。<br/>
另外，一旦决定分层，我们可以通过优化通讯方式、通讯协议，尽可能把损耗降到最低。</p>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);"><span style="font-weight: 700;">举个例子：</span><br/>
淘宝宝贝详情页静态化之后，还是有不少需要实时获取的信息，比如物流、促销等等，因为这些信息在不同业务系统中，所以需要前端发送5，6个异步请求来回填这些内容。<br/>
有了NodeJS之后，前端可以在NodeJS中去代理这5个异步请求，还能很容易的做Bigpipe,这块的优化能让整个渲染效率提升很多。<br/>
可能在PC上你觉得发5,6个异步请求也没什么，但是在无线端，在客户手机上建立一个HTTP请求开销很大，有了这个优化，性能一下提升好几倍。</p>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">淘宝详情基于NodeJS的优化我们正在进行中，上线之后我会分享一下优化的过程。</p>
<h4 style="padding: 0px; font-size: 16px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">3.4 前端的工作量是否增加了？</h4>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">相对于只切页面/做demo，肯定是增加了一点，但是当前模式下有联调、沟通环节，这个过程非常花时间，也容易出bug，还很难维护。<br/>
所以，虽然工作量会增加一点，但是总体开发效率会提升很多。</p>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">另外，测试成本可以节省很多。以前开发的接口都是针对表现层的，很难写测试用例。如果做了前后端分离，甚至测试都可以分开，一拨人专门测试接口，一拨人专注测试UI（这部分工作甚至可以用工具代替）。</p>
<h4 style="padding: 0px; font-size: 16px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">3.5 增加Node层带来的风险怎么控制？</h4>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">随着Node大规模使用，系统/运维/安全部门的同学也一定会加入到基础建设中，他们会帮助我们去完善各个环节可能出现的问题，保障系的稳定性。</p>
<h4 style="padding: 0px; font-size: 16px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">3.6 Node什么都能做，为什么还要JAVA？</h4>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">我们的初衷是做前后端分离，如果考虑这个问题就有点违背我们的初衷了。即使用Node替代Java，我们也没办法保证不出现今天遇到的种种问题，比如职责不清。我们的目的是分层开发，专业的人，专注做专业的事。基于JAVA的基础架构已经非常强大而且稳定，而且更适合做现在架构的事情。</p>
<h2 style="padding: 0px; font-size: 24px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; line-height: 36px; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">四、淘宝基于Node的前后端分离</h2>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/c039175633ba0140e768ec21b8d37142.jpeg" height="521" width="800"/></p>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">上图是我理解的淘宝基于Node的前后端分离分层，以及Node的职责范围。简单解释下：</p>
<ul style="padding: 0px; list-style-position: initial; list-style-image: initial; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">
<li style=" padding: 0px;">最上端是服务端，就是我们常说的后端。后端对于我们来说，就是一个接口的集合，服务端提供各种各样的接口供我们使用。因为有Node层，也不用局限是什么形式的服务。对于后端开发来说，他们只用关心业务代码的接口实现。</li>
<li style=" padding: 0px;">服务端下面是Node应用。</li>
<li style=" padding: 0px;">Node应用中有一层Model Proxy与服务端进行通讯。这一层主要目前是抹平我们对不同接口的调用方式，封装一些view层需要的Model。</li>
<li style=" padding: 0px;">Node层还能轻松实现原来vmcommon,tms（引用淘宝内容管理系统）等需求。</li>
<li style=" padding: 0px;">Node层要使用什么框架由开发者自己决定。不过推荐使用express+xTemplate的组合，xTemplate能做到前后端公用。</li>
<li style=" padding: 0px;">怎么用Node大家自己决定，但是令人兴奋的是，我们终于可以使用Node轻松实现我们想要的输出方式:JSON/JSONP/RESTful/HTML/BigPipe/Comet/Socket/同步、异步，想怎么整就怎么整，完全根据你的场景决定。</li>
<li style=" padding: 0px;">浏览器层在我们这个架构中没有变化，也不希望因为引入Node改变你以前在浏览器中开发的认知。</li>
<li style=" padding: 0px;">引入Node，只是把本该就前端控制的部分交由前端掌控。</li>
</ul>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">这种模式我们已经有两个项目在开发中，虽然还没上线，但是无论是在开发效率，还是在性能优化方面，我们都已经尝到了甜头。</p>
<h2 style="padding: 0px; font-size: 24px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; line-height: 36px; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">五、我们还需要要做什么？</h2>
<ul style="padding: 0px; list-style-position: initial; list-style-image: initial; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">
<li style=" padding: 0px;">把Node的开发流程集成到淘宝现有的SCM流程中。</li>
<li style=" padding: 0px;">基础设施建设，比如session,logger等通用模块。</li>
<li style=" padding: 0px;">最佳开发实践</li>
<li style=" padding: 0px;">线上成功案例</li>
<li style=" padding: 0px;">大家对Node前后端分离概念的认识</li>
<li style=" padding: 0px;">安全</li>
<li style=" padding: 0px;">性能</li>
<li style=" padding: 0px;">…</li>
</ul>
<p style="padding: 0px; color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px; background-color: rgb(255, 255, 255);">技术上不会有太多需要去创新和研究的，已经有非常多现成的积累。其实关键是一些流程的打通和通用解决方案的积累，相信随着更多的项目实践，这块慢慢会变成一个稳定的流程。</p>
<h2 style="padding: 0px; font-size: 24px; clear: both; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; line-height: 36px; color: rgb(74, 74, 74); background-color: rgb(255, 255, 255);">六、“中途岛”</h2>
<h1 style="padding: 0px; font-size: 17px; line-height: 23px; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Microsoft Yahei'; background-color: rgb(255, 255, 255);"><span style="color: rgb(74, 74, 74); font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 23.001998901367188px;">虽然“基于NodeJS的全栈式开发”模式很让人兴奋，但是把基于Node的全栈开发变成一个稳定，让大家都能接受的东西还有很多路要走，我们正在进行的“中途岛”项目就是为了解决这个问题。虽然我们起步不久，但是离目标已经越来越近！！</span> </h1>
<h1 style="box-sizing: border-box; font-size: 30px; line-height: 1.1; font-weight: normal; word-wrap: break-word; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box;">Web 研发模式演变</span></h1>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);"><a href="https://camo.githubusercontent.com/2ac8d073ba00bde4270a3c0530490255392ca162/687474703a2f2f696d672e68622e616963646e2e636f6d2f6366323535396466303137396666346431666630336463346465663961386334666661376435346531626134662d695355784373" target="_blank" style="box-sizing: border-box; color: rgb(65, 131, 196); text-decoration: none;"><span style="-evernote-last-insertion-point:true;"/><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/f2dc613df98e3cba17d5921c63cfa88d.jpeg" height="514" width="432"/></a></p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">前不久徐飞写了一篇很好的文章：<a href="http://goo.gl/DKNX6z" style="box-sizing: border-box; color: rgb(65, 131, 196); text-decoration: none;">Web 应用的组件化开发</a>。本文尝试从历史发展角度，说说各种研发模式的优劣。</p>
<h2 style="box-sizing: border-box; line-height: 1.7; font-size: 2em; padding: 0px; cursor: text; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; background-color: rgb(255, 255, 255);">一、简单明快的早期时代</h2>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);"><a href="https://camo.githubusercontent.com/90850e93b917cd3c958dff1c7d0197f819167343/687474703a2f2f696d672e68622e616963646e2e636f6d2f63333639616163633864613338616638653432326664323935313438633537643162353831376666666335362d4f636250646c5f6677363538" target="_blank" style="box-sizing: border-box; color: rgb(65, 131, 196); text-decoration: none;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/0f60aa232eba55c9ec316ef9dfd752f0.jpeg" height="379" width="542"/></a></p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">可称之为 Web 1.0 时代，非常适合创业型小项目，不分前后端，经常 3-5 人搞定所有开发。页面由 JSP、PHP 等工程师在服务端生成，浏览器负责展现。基本上是服务端给什么浏览器就展现什么，展现的控制在 Web Server 层。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">这种模式的好处是：简单明快，本地起一个 Tomcat 或 Apache 就能开发，调试什么的都还好，只要业务不太复杂。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">然而业务总会变复杂，这是好事情，否则很可能就意味着创业失败了。业务的复杂会让 Service 越来越多，参与开发的人员也很可能从几个人快速扩招到几十人。在这种情况下，会遇到一些典型问题：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">1、<strong style="box-sizing: border-box;">Service 越来越多，调用关系变复杂，前端搭建本地环境不再是一件简单的事。</strong>考虑团队协作，往往会考虑搭建集中式的开发服务器来解决。这种解决方案对编译型的后端开发来说也许还好，但对前端开发来说并不友好。天哪，我只是想调整下按钮样式，却要本地开发、代码上传、验证生效等好几个步骤。也许习惯了也还好，但开发服务器总是不那么稳定，出问题时往往需要依赖后端开发搞定。看似仅仅是前端开发难以本地化，但这对研发效率的影响其实蛮大。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">2、**JSP 等代码的可维护性越来越差。**JSP 非常强大，可以内嵌 Java 代码。这种强大使得前后端的职责不清晰，JSP 变成了一个灰色地带。经常为了赶项目，为了各种紧急需求，会在 JSP 里揉杂大量业务代码。积攒到一定阶段时，往往会带来大量维护成本。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">这个时期，为了提高可维护性，可以通过下面的方式实现前端的组件化：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);"><a href="https://camo.githubusercontent.com/bbbf666300ccea8dc4f5deb3f22773195555d3ac/687474703a2f2f696d672e68622e616963646e2e636f6d2f3835393365623736663966353163613735333933333234333131303933623731356235373637316531313466342d6e61677936445f6677363538" target="_blank" style="box-sizing: border-box; color: rgb(65, 131, 196); text-decoration: none;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/020bc6b339f482906d2ae9d9973eebcb.jpeg" height="384" width="545"/></a></p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">理论上，如果大家都能按照最佳实践去书写代码，那么无论是 JSP 还是 PHP，可维护性都不会差。<strong style="box-sizing: border-box;">但可维护性更多是工程含义，有时候需要通过限制带来自由，需要某种约定，使得即便是新手也不会写出太糟糕的代码。</strong></p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);"><strong style="box-sizing: border-box;">如何让前后端分工更合理高效，如何提高代码的可维护性，在 Web 开发中很重要。</strong>下面我们继续来看，技术架构的演变如何解决这两个问题。</p>
<h2 style="box-sizing: border-box; line-height: 1.7; font-size: 2em; padding: 0px; cursor: text; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; background-color: rgb(255, 255, 255);">二、后端为主的 MVC 时代</h2>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">为了降低复杂度，以后端为出发点，有了 Web Server 层的架构升级，比如 Structs、Spring MVC 等，这是后端的 MVC 时代。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);"><a href="https://camo.githubusercontent.com/b9e16b0b3ff3361a481badaca7d408e8fa6b404f/687474703a2f2f696d672e68622e616963646e2e636f6d2f3961366266353237646162626462396237393563353862306237616636633761313864653963653331316136312d3975697578545f6677363538" target="_blank" style="box-sizing: border-box; color: rgb(65, 131, 196); text-decoration: none;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/faffd4789c58d1734687d1b12b647ed0.jpeg" height="352" width="540"/></a></p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">代码可维护性得到明显好转，MVC 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方。为了让 View 层更简单干脆，还可以选择 Velocity、Freemaker 等模板，使得模板里写不了 Java 代码。看起来是功能变弱了，但正是这种限制使得前后端分工更清晰。然而依旧并不是那么清晰，这个阶段的典型问题是：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">1、<strong style="box-sizing: border-box;">前端开发重度依赖开发环境。</strong>这种架构下，前后端协作有两种模式：一种是前端写 demo，写好后，让后端去套模板。淘宝早期包括现在依旧有大量业务线是这种模式。好处很明显，demo 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大。另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发，支付宝是这种模式。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">2、**前后端职责依旧纠缠不清。**Velocity 模板还是蛮强大的，变量、逻辑、宏等特性，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller，页面路由等功能本应该是前端最关注的，但却是由后端来实现。Controller 本身与 Model 往往也会纠缠不清，看了让人咬牙的代码经常会出现在 Controller 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">经常会有人吐槽 Java，但 Java 在工程化开发方面真的做了大量思考和架构尝试。Java 蛮符合马云的一句话：让平凡人做非凡事。</p>
<h2 style="box-sizing: border-box; line-height: 1.7; font-size: 2em; padding: 0px; cursor: text; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; background-color: rgb(255, 255, 255);">三、Ajax 带来的 SPA 时代</h2>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">历史滚滚往前，2004 年 Gmail 像风一样的女子来到人间，很快 2005 年 Ajax 正式提出，加上 CDN 开始大量用于静态资源存储，于是出现了 JavaScript 王者归来的 SPA （Single Page Application 单页面应用）时代。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);"><a href="https://camo.githubusercontent.com/d0098546c9fa01b443c16ff1953c90aa9056955b/687474703a2f2f696d672e68622e616963646e2e636f6d2f3932393766646337336438336632373764343439633932313933613361663432386464633064343431316366392d6e31445936465f6677363538" target="_blank" style="box-sizing: border-box; color: rgb(65, 131, 196); text-decoration: none;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/c97fafc54d66055808733b96fd459cb9.jpeg" height="379" width="538"/></a></p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);"><a href="https://camo.githubusercontent.com/f064bc7a5b06ea9a39cf039a5dec0ca6675141ff/687474703a2f2f696d672e68622e616963646e2e636f6d2f3135383839323134336263363430333364323264643865643765373533366537316530373063346131336335372d6850673150635f6677363538" target="_blank" style="box-sizing: border-box; color: rgb(65, 131, 196); text-decoration: none;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/6909036526aa325f60715860af280169.jpeg" height="376" width="540"/></a></p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">对于 SPA 应用，有几个很重要的挑战：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">1、<strong style="box-sizing: border-box;">前后端接口的约定。</strong>如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦。这一块在业界有 API Blueprint 等方案来约定和沉淀接口，在阿里，不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。相信这一块会越做越好。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">2、**前端开发的复杂度控制。**SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。典型的解决方案是业界的 Backbone，但 Backbone 做的事还很有限，依旧存在大量空白区域需要挑战。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">SPA 让前端看到了一丝绿色，但依旧是在荒漠中行走。</p>
<h2 style="box-sizing: border-box; line-height: 1.7; font-size: 2em; padding: 0px; cursor: text; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; background-color: rgb(255, 255, 255);">四、前端为主的 MV* 时代</h2>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">为了降低前端开发复杂度，除了 Backbone，还有大量框架涌现，比如 EmberJS、KnockoutJS、AngularJS 等等。这些框架总的原则是先按类型分层，比如 Templates、Controllers、Models，然后再在层内做切分，如下图：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);"><a href="https://camo.githubusercontent.com/2ab0e0e247dfae7b74760b7d57056a680204874d/687474703a2f2f696d672e68622e616963646e2e636f6d2f3536663463656530653663376166363165323464626633316534626531376631343264353930326331313039612d42637852696d5f6677363538" target="_blank" style="box-sizing: border-box; color: rgb(65, 131, 196); text-decoration: none;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/3a41858639f8e3f4ad7438737fad6d17.jpeg" height="382" width="541"/></a></p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">好处很明显：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">1、<strong style="box-sizing: border-box;">前后端职责很清晰。</strong>前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">2、<strong style="box-sizing: border-box;">前端开发的复杂度可控。</strong>前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本的厚度去说明。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">3、<strong style="box-sizing: border-box;">部署相对独立</strong>，产品体验可以快速改进。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">但依旧有不足之处：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">1、代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。<br style="box-sizing: border-box;"/>
<br/>
2、全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。<br style="box-sizing: border-box;"/>
<br/>
3、性能并非最佳，特别是移动互联网环境下。<br style="box-sizing: border-box;"/>
<br/>
4、SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌控。</p>
<h2 style="box-sizing: border-box; line-height: 1.7; font-size: 2em; padding: 0px; cursor: text; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; background-color: rgb(255, 255, 255);">五、Node 带来的全栈时代</h2>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 Node.js 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);"><a href="https://camo.githubusercontent.com/ed895cf7561cb3ec07ef74aa2dea573b57dbe219/687474703a2f2f696d672e68622e616963646e2e636f6d2f3430303931653637316230626465653236653531366163303530633663616563383038383562386131326238372d374a676646685f6677363538" target="_blank" style="box-sizing: border-box; color: rgb(65, 131, 196); text-decoration: none;"><img src="%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A4%9A%E7%BB%88%E7%AB%AF%E9%80%82%E9%85%8D.resources/295de11b2958a3b10b8f8494ef7bd587.png" height="611" width="590"/></a></p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">1、Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">2、Back-end UI layer 处理路由、模板、数据获取、cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">基于 Node 的全栈模式，依旧面临很多挑战：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">1、需要前端对服务端编程有更进一步的认识。比如 network/tcp、PE 等知识的掌握。<br style="box-sizing: border-box;"/>
<br/>
2、Node 层与 Java 层的高效通信。Node 模式下，都在服务器端，RESTful HTTP 通信未必高效，通过 SOAP 等方式通信更高效。一切需要在验证中前行。<br style="box-sizing: border-box;"/>
<br/>
3、对部署、运维层面的熟练了解，需要更多知识点和实操经验。<br style="box-sizing: border-box;"/>
<br/>
4、大量历史遗留问题如何过渡。这可能是最大最大的阻力。</p>
<h2 style="box-sizing: border-box; line-height: 1.7; font-size: 2em; padding: 0px; cursor: text; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; background-color: rgb(255, 255, 255);">六、小结</h2>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">回顾历史总是让人感慨，展望未来则让人兴奋。上面讲到的研发模式，除了最后一种还在探索期，其他各种在各大公司都已有大量实践。几点小结：</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">1、模式没有好坏高下之分，只有合不合适。<br style="box-sizing: border-box;"/>
<br/>
2、Ajax 给前端开发带来了一次质的飞跃，Node 很可能是第二次。<br style="box-sizing: border-box;"/>
<br/>
3、SoC（关注度分离） 是一条伟大的原则。上面种种模式，都是让前后端的职责更清晰，分工更合理高效。<br style="box-sizing: border-box;"/>
<br/>
4、还有个原则，让合适的人做合适的事。比如 Web Server 层的 UI Layer 开发，前端是更合适的人选。</p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);"><strong style="box-sizing: border-box;">历史有时候会打转，咋一看以为是回去了，实际上是螺旋转了一圈，站在了一个新的起点。</strong></p>
<p style="box-sizing: border-box; color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px; background-color: rgb(255, 255, 255);">（完）</p>
<div><span style="background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 23.799999237060547px;">题图：演化真不容易呀。</span><span style="box-sizing: border-box;"><br/></span></div>
<div><span style="background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; letter-spacing: 0.03rem; line-height: 27.200000762939453px;"><br/></span></div>
</body></html>