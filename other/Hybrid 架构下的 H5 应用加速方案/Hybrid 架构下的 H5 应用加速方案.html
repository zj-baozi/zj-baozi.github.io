<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 5.4.4 (402282)"/><meta name="author" content="jennyzj"/><meta name="created" content="2014-05-26 07:50:07 +0000"/><meta name="updated" content="2014-05-26 07:50:19 +0000"/><title>Hybrid 架构下的 H5 应用加速方案</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
<p style="box-sizing: border-box; letter-spacing: 0.03rem; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft Yahei', sans-serif; font-size: 16px; line-height: 27.200000762939453px; background-color: rgb(255, 255, 255);"><span style="-evernote-last-insertion-point:true;"/> <span style="box-sizing: border-box; color: rgb(68, 68, 68); line-height: 20px;">在移动 App 开发领域，主流的开发模式可分为 Native、Hybrid、WebApp 三种方式。然而 2013 年，纯 WebApp 开发模式的发展受到一定挫折，以 Facebook 为代表的独立 App 转投 Native 阵营。但是开发者对 WebApp 更新速度快，跨平台优势的渴望却并未减弱，最终的结果是促成了 Hybrid App 在 2013 年数量的激增，并且增长的速率非常之快。 简单的说，Hybrid App是 Native App 和 Mobile Web 二者混合开发的产物，HTML5  的页面被嵌入到 Natvie App 的 webview 中。因此它综合了更新速度快，交互体验好，跨平台等优点。</span></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">本文分享的就是 HTML5 页面(尤其是被嵌入的 H5 应用) 借助 Hybrid 架构来提升自己的加载速度和性能的一种解决方案。该方案要求你对 Hybrid App 进行以下三步骤的改造：</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">一：模块化你的 H5 页面/</span><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">应用，引入模块加载器（可选）</span></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">模块加载器不必多说，SeaJS、requireJS、kissy loader 等耳熟能详，任你挑选。使用模块化的方式来开发你的应用，不仅仅将有利于后期的代码维护，在 Hrbrid 的架构中，还将会有利于性能的提升。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">或许你有疑问：模块开发粒度越细化，加载时请求的JS、CSS等静态资源的数量越多，页面的性能不会越差吗？我的回答是：如果你仅仅是使用了模块加载器并异步加载各个模块，那么加载的性能一定很差，因为请求的数量太多。当然你肯定会想到在发布前打包合并静态资源，那么对这样的解决方案我只能给到 50 分，因为被打包合并的文件中只要有一个子文件发生变化，那么整个文件（JS或CSS）都要被重新下载，对移动带宽而言还是个负担。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">怎么破？请继续进行步骤二：<br style="box-sizing: border-box; font-family: inherit;"/>
<br/>
<br style="box-sizing: border-box; font-family: inherit;"/>
<br/>
<span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">二：启用 AppCache ，并引入增量更新机制</span></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">        </span>做过 WebApp 的同学应该会了解 <a href="http://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(255, 115, 0); text-decoration: none; font-family: inherit; background-position: initial initial; background-repeat: initial initial;">mainfest </a>文件，Html5提供的应用缓存功能，开发者只要把需被缓存的静态资源文件名罗列在这个列表中即可保证二次访问时无需重新加载。看起来不错！这样前面说的模块化开发造成的请求数量过多的问题，至少在二次访问时不会再发生了。嗯，这样的方案可以给到 70 分吧。其实，Html5 提供的 mainfest 缓存机制有个比较大的问题（兼容性就先不提了）：如果 mainfest 列表中的一个资源文件需要更新，那么整个 mainfest 中的其它文件也都需要被重新下载一遍。 也即是说二次访问没有问题了，但是 Html5 应用更新时还是会出现全量下载的问题。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">     </span>   别忘了，我们是 Hybrid App，还可以充分利用 Native 层的强大能力，所以抛弃mainfest吧，让 Native 来帮助 Html5 应用缓存静态资源文件。总体思路是：</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">1、Html5 应用首次启动时，调用 Native 提供的加载资源文件专用的 Device API 来请求所需的资源文件，由 Native 层发出真正的资源请求，并将请求结果缓存在手机的SD卡上。当然，这里完全可以优化为一次 zip 包请求，因为 native 能够提供强大的解压能力。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">2、H5 应用再次启动时，所有的静态资源都是通过 Device API 读取本地缓存，无需再走网络。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">3、H5 应用出现静态资源更新时，在应用启动时首先通过 Device API 加载<span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">需要更新的文件</span>，并更新本地缓存，其它未变更文件继续走缓存。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">    </span>    流程看起来挺顺，其中有几个关键问题需要解决：<span style="box-sizing: border-box; font-weight: 700; font-family: inherit;"><br style="box-sizing: border-box; font-family: inherit;"/>
<br/></span></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;"> 1、如何通过 Device API 加载资源文件？</span></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">      这里使用模块加载器的优势就体现出来了，只需要在加载器中做点小修改，不直接走Http请求了，而直接调用 Native 提供的文件加载 DeviceAPI 即可。 如果你没有模块加载器，就需要写统一的函数来做加载资源的功能了。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">其实 Native 也提供了拦截机制，能够拦截到 H5 应用发出的所有 Http 请求并进行自定义处理，可惜这样好的功能在 Andorid 4.0 以下版本不支持。 故现阶段还是主动调用 Device API 更靠谱。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;"> 2、</span><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">何时需要进行静态资源的更新</span>？</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">       </span>每次静态资源发布都会产生一个唯一的发布时间戳（或是所有资源内容的MD5编码），H5应用启动后，可将当前时间戳保存下来，等应用下次启动时，请求最新的发布时间戳并与本地时间戳进行对比，若不同，则首先进行静态资源的增量更新。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;"> 3、</span><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">如何判断哪些是需要被增量更新替代的静态资源文件？</span></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">这个问题的回答会比较复杂些，核心思路是通过对前后两次资源文件（js、css、image等）发布的内容对比完成：</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><a href="http://www.aliued.cn/wp-content/uploads/2014/03/zengliang.jpg" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(255, 115, 0); text-decoration: none; font-family: inherit; background-position: initial initial; background-repeat: initial initial;"><img src="Hybrid%20%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%20H5%20%E5%BA%94%E7%94%A8%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88.resources/f2dda2ef9fb5a3347ffb9c5337879fe7.jpeg" height="389" width="700"/></a></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">如此，H5 应用借助 Native 应用的能力完成了资源的缓存与增量更新，可以保证 H5 应用在启动与更新时的加载速度。当然也有方案借助 HTML5 的 localstorage 来替代 Native 的缓存更新策略，但是可能会受到两处限制：</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">1、若 Hybrid App 比较复杂，涉及多个子域甚至主域间的静态资源共享，则 localstorage 的方案首先要解决跨域访问的问题，并且在每个子域存储空间上存在上限，是 5M。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">2、Native 能够支持更新包的 zip 打包下载，一次请求，然后解压并更新本地缓存。而 localstorage 无法实现。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">若应用中以上两点不是问题，则使用 localstorage 缓存的策略完全 OK。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><span style="box-sizing: border-box; font-weight: 700; font-family: inherit;">三：启用 spdy 协议</span></p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><a href="http://www.open-open.com/news/view/1830e9a" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(255, 115, 0); text-decoration: none; font-family: inherit; background-position: initial initial; background-repeat: initial initial;">spdy </a>协议在移动开发上大有可为，它是HTTP协议的增强版本，能够通过一次TCP链接同时请求到多个资源文件，请求速度上的提升那是自然的了，非常强大！chrome 等 webkit 内核浏览器都已经支持。 可惜若是借助浏览器自身使用 spdy 协议则要求静态资源服务（js、css、image）必须是 https 的域名服务，且<a href="http://tengine.taobao.org/index_cn.html" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(255, 115, 0); text-decoration: none; font-family: inherit; background-position: initial initial; background-repeat: initial initial;">后台server</a> 能支持spdy协议。相信大多数静态服务器都还是http 服务，是无法通过浏览器来直接支持的。（最近有个好消息是集团的大部分静态CDN服务会提供 spdy 协议支持）</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">还是那句话，因为我们是 hybrid 应用，可以发挥native的优势！ native 层完全可以实现基于 spdy 协议请求的 device API，供 H5 应用（JS）来调用。这样就不需要 https 域名服务器也能使用 spdy了。</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">如果你的 Hybrid 应用已经支持了 spdy 协议，那么你可以考虑不再需要把增量更新的资源文件打包成 zip 下载了，直接 spdy 协议并行下载即可！</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;">SPDY 与 HTTP 协议速度对比：</p>
<p style="box-sizing: border-box; letter-spacing: 0.03rem; font-family: inherit; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); line-height: 20px;"><a href="http://www.aliued.cn/wp-content/uploads/2014/03/image001.png" target="_blank" style="box-sizing: border-box; background-color: transparent; color: rgb(255, 115, 0); text-decoration: none; font-family: inherit; background-position: initial initial; background-repeat: initial initial;"><img src="Hybrid%20%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%20H5%20%E5%BA%94%E7%94%A8%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88.resources/703934938cc8f0ec7cf3d55c23ce02dd.png" height="324" width="828"/></a></p>
<span style="background-color: rgb(255, 255, 255); color: rgb(68, 68, 68); font-family: inherit; font-size: 16px; letter-spacing: 0.03rem; line-height: 20px;">以上解决方案已应用在1688主客户端5.0版本的架构设计中，有改进之处，欢迎探讨~</span>
</body></html>